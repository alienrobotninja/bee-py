from hashlib import sha3_256
from typing import Optional, Union

import eth_keys  # type: ignore
from ape.managers.accounts import AccountAPI
from ape.types import AddressType
from ape.types.signatures import MessageSignature
from ecdsa import SECP256k1, VerifyingKey  # type: ignore
from eth_account.messages import SignableMessage, encode_defunct
from eth_keys import keys
from eth_pydantic_types import HexBytes

# bee_py imports
from bee_py.utils.hash import keccak256_hash
from bee_py.utils.hex import hex_to_bytes

# Variables
UNCOMPRESSED_RECOVERY_ID = 27


def hash_with_ethereum_prefix(data: Union[bytes, bytearray]) -> bytes:
    """
    Calculates the Keccak-256 hash of the provided data, prefixed with the Ethereum signed message prefix.

    Args:
        data (bytes): The data to be hashed.

    Returns:
        bytes: The Keccak-256 hash of the prefixed data.
    """

    ethereum_signed_message_prefix = f"\x19Ethereum Signed Message:\n{len(data)}"
    prefix_bytes = ethereum_signed_message_prefix.encode("utf-8")

    return keccak256_hash(prefix_bytes, data)


# TODO: Update the implementation when this PR is merged https://github.com/ApeWorX/ape/pull/1734
def sign(
    data: Union[str, bytes, bytearray, SignableMessage],
    account: AccountAPI,
    auto_sign: Optional[bool] = False,  # noqa: FBT002
) -> Optional[MessageSignature]:
    """
    Calculates the signature of the provided data using the given private key.

    Args:
        data(str, bytes, bytearray, SignableMessage): The data to be signed.
        account: ape account
        auto_sign(Optional[bool]): Whether to enable auto-signing for the account

    Returns:
        MessageSignature -> The signature of the data as HexBytes

    N.B. It is not recoomened to pass private key here & there that's why I
    thought to use ape's account container which is much more secure than just
    passing the private key while calling this function.
    """

    if not isinstance(data, SignableMessage):
        if isinstance(data, str):
            data = encode_defunct(text=data)
        else:
            data = encode_defunct(data)

    # * you have to set password as env variable
    # * more info here: https://docs.apeworx.io/ape/stable/userguides/accounts.html#keyfile-passphrase-environment-variable-more-secure # noqa: E501
    if auto_sign:
        account.set_autosign(True)  # type: ignore

    signature = account.sign_message(data)

    # return the signature
    return signature


# for more info ckeckout my gist: https://gist.github.com/Aviksaikat/fd5dfaef4c69e23116148b4b7c0377b6
def public_key_to_address(pub_key: Union[str, bytes, eth_keys.datatypes.PublicKey]) -> HexBytes:
    """
    Converts an elliptic curve public key into its corresponding Ethereum address.

    Args:
        pub_key (str | bytes | eth_keys.datatypes.PublicKey ): The elliptic curve public key.

    Returns:
        EthAddress(HexBytes): The Ethereum address derived from the public key.
    """
    if isinstance(pub_key, str):
        hash_of_public_key = keys.PublicKey(hex_to_bytes(pub_key))
    elif isinstance(pub_key, bytes):
        hash_of_public_key = keys.PublicKey(pub_key)
    # * if already an eth_keys.datatypes.PublicKey object then call the .to_address method & return
    elif isinstance(pub_key, eth_keys.datatypes.PublicKey):
        return HexBytes(pub_key.to_address())
    else:
        msg = f"Expected str, bytes or hexstr, got {pub_key}"
        raise ValueError(msg)
    # Extract the last 20 bytes (40 characters) from the keccak digest as the address
    address = hash_of_public_key.to_address()
    return HexBytes(address)


def recover_address(signature: bytes, digest: bytes) -> Union[AddressType, str]:
    """
    Recovers the Ethereum address from a given signature and message digest.

    This function can be used to verify the authenticity of a message by comparing
    the recovered address with the actual address of the signer.

    Args:
        signature (bytes): The signature generated by the signer.
        digest (bytes): The message digest of the data to be verified.

    Returns:
        AddressType: The recovered Ethereum address.
    """
    curve = SECP256k1
    hash_value = hash_with_ethereum_prefix(digest)

    vk = VerifyingKey.from_public_key_recovery_with_digest(signature[:64], hash_value, curve, sha3_256)

    return public_key_to_address(vk[0].to_string()).hex()
